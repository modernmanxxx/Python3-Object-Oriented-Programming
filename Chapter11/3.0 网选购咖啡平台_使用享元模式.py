class 咖啡(object):
    名称 = ''
    价格 = 0

    def __init__(self, 名称):
        self.名称 = 名称
        # 在实际业务中，咖啡价格应该是由配置表进行配置，或者调用接口获取等方式得到，此处为说明享元模式，将咖啡价格定为名称长度，只是一种简化
        self.价格 = len(名称)

    def show(self):
        print("咖啡名:%s 价格:%s" % (self.名称, self.价格))


class 顾客(object):
    """重写"""
    咖啡工厂 = ""
    名称 = ""

    def __init__(self, 名称, 咖啡工厂):
        self.名称 = 名称
        self.咖啡工厂 = 咖啡工厂

    def 订购(self, 咖啡名):
        print ("%s 订购了一杯咖啡:%s" % (self.名称, 咖啡名))
        return self.咖啡工厂.getCoffee(咖啡名)
"""
简单分析下业务流程，高并发下用户数量增加，而该模型下，每个用户点一杯咖啡，就会产生一个咖啡实例，
如果一种咖啡在该时间内被很多用户点过，那么就会产生很多同样咖啡的实例。
避免重复实例的出现，是节约系统资源的一个突破口。类似于单例模式，我们这里在咖啡实例化前，增加一个控制实例化的类：咖啡工厂。
"""

class 咖啡工厂(object):
    咖啡字典 = {}

    def getCoffee(self, 名称):
        if self.咖啡字典.__contains__(名称) == False:
            self.咖啡字典[名称] = 咖啡(名称)
        return self.咖啡字典[名称]

    def 获取咖啡实例统计(self):
        """咖啡工厂中，getCoffeeCount直接返回当前实例个数"""
        return len(self.咖啡字典)


if __name__ == "__main__":
    咖啡工厂 = 咖啡工厂()
    客户1 = 顾客("A客户", 咖啡工厂)
    客户2 = 顾客("B客户", 咖啡工厂)
    客户3 = 顾客("C客户", 咖啡工厂)
    客户1雀巢 = 客户1.订购("雀巢")
    客户1雀巢.show()

    客户2雀巢 = 客户2.订购("雀巢")
    客户2雀巢.show()
    客户3猫屎 = 客户3.订购("猫屎")
    客户3猫屎.show()
    print ("咖啡实例数量:%s" % 咖啡工厂.获取咖啡实例统计())

"""
其实这是利用了字典的特性:唯一性,来避免生成重复对象.
"""
